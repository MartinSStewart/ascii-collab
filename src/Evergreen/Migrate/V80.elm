module Evergreen.Migrate.V80 exposing (..)

{-| This migration file was automatically generated by the lamdera compiler.

It includes:

  - A migration for each of the 6 Lamdera core types that has changed
  - A function named `migrate_ModuleName_TypeName` for each changed/custom type

Expect to see:

  - `Unimplement–µd` values as placeholders wherever I was unable to figure out a clear migration path for you
  - `@NOTICE` comments for things you should know about, i.e. new custom type constructors that won't get any
    value mappings from the old type by default

You can edit this file however you wish! It won't be generated again.

See <https://dashboard.lamdera.app/docs/evergreen> for more info.

-}

import AssocList
import Dict
import EmailAddress
import Evergreen.V79.Ascii
import Evergreen.V79.Bounds
import Evergreen.V79.Grid
import Evergreen.V79.GridCell
import Evergreen.V79.Helper
import Evergreen.V79.LocalGrid
import Evergreen.V79.NotifyMe
import Evergreen.V79.RecentChanges
import Evergreen.V79.Types
import Evergreen.V79.Units
import Evergreen.V79.UrlHelper
import Evergreen.V79.User
import Evergreen.V80.Ascii
import Evergreen.V80.Bounds
import Evergreen.V80.EmailAddress2
import Evergreen.V80.Grid
import Evergreen.V80.GridCell
import Evergreen.V80.Helper
import Evergreen.V80.LocalGrid
import Evergreen.V80.NotifyMe
import Evergreen.V80.RecentChanges
import Evergreen.V80.Types
import Evergreen.V80.Units
import Evergreen.V80.UrlHelper
import Evergreen.V80.User
import Lamdera.Migrations exposing (..)
import List
import List.Nonempty
import Maybe
import Parser exposing ((|.), (|=), Parser)
import Quantity
import SeqDict
import SeqSet


frontendModel : Evergreen.V79.Types.FrontendModel -> ModelMigration Evergreen.V80.Types.FrontendModel Evergreen.V80.Types.FrontendMsg
frontendModel old =
    ModelReset


backendModel : Evergreen.V79.Types.BackendModel -> ModelMigration Evergreen.V80.Types.BackendModel Evergreen.V80.Types.BackendMsg
backendModel old =
    ModelMigrated ( migrate_Types_BackendModel old, Cmd.none )


frontendMsg : Evergreen.V79.Types.FrontendMsg -> MsgMigration Evergreen.V80.Types.FrontendMsg Evergreen.V80.Types.FrontendMsg
frontendMsg old =
    MsgOldValueIgnored


toBackend : Evergreen.V79.Types.ToBackend -> MsgMigration Evergreen.V80.Types.ToBackend Evergreen.V80.Types.BackendMsg
toBackend old =
    MsgOldValueIgnored


backendMsg : Evergreen.V79.Types.BackendMsg -> MsgMigration Evergreen.V80.Types.BackendMsg Evergreen.V80.Types.BackendMsg
backendMsg old =
    MsgOldValueIgnored


toFrontend : Evergreen.V79.Types.ToFrontend -> MsgMigration Evergreen.V80.Types.ToFrontend Evergreen.V80.Types.FrontendMsg
toFrontend old =
    MsgOldValueIgnored


migrate_Types_BackendModel : Evergreen.V79.Types.BackendModel -> Evergreen.V80.Types.BackendModel
migrate_Types_BackendModel old =
    { grid = old.grid |> migrate_Grid_Grid
    , userSessions =
        old.userSessions
            |> Dict.map
                (\k ->
                    \rec ->
                        { clientIds = rec.clientIds |> Dict.map (\k2 -> migrate_Bounds_Bounds migrate_Units_CellUnit)
                        , userId = rec.userId |> migrate_User_UserId
                        }
                )
    , users = old.users |> Dict.map (\k -> migrate_Types_BackendUserData)
    , usersHiddenRecently =
        old.usersHiddenRecently
            |> List.map
                (\rec ->
                    { reporter = rec.reporter |> migrate_User_UserId
                    , hiddenUser = rec.hiddenUser |> migrate_User_UserId
                    , hidePoint = rec.hidePoint |> migrate_Helper_Coord migrate_Units_AsciiUnit
                    }
                )
    , userChangesRecently = old.userChangesRecently |> migrate_RecentChanges_RecentChanges
    , subscribedEmails = old.subscribedEmails |> List.map migrate_Types_SubscribedEmail
    , pendingEmails = old.pendingEmails |> List.map migrate_Types_PendingEmail
    , secretLinkCounter = old.secretLinkCounter
    , errors = []
    , dummyField = old.dummyField
    }


migrate_Ascii_Ascii : Evergreen.V79.Ascii.Ascii -> Evergreen.V80.Ascii.Ascii
migrate_Ascii_Ascii old =
    case old of
        Evergreen.V79.Ascii.Ascii p0 ->
            Evergreen.V80.Ascii.Ascii p0


migrate_Bounds_Bounds : (unit_old -> unit_new) -> Evergreen.V79.Bounds.Bounds unit_old -> Evergreen.V80.Bounds.Bounds unit_new
migrate_Bounds_Bounds migrate_unit old =
    case old of
        Evergreen.V79.Bounds.Bounds p0 ->
            Evergreen.V80.Bounds.Bounds
                { min = p0.min |> migrate_Helper_Coord migrate_unit
                , max = p0.max |> migrate_Helper_Coord migrate_unit
                }


migrate_EmailAddress2_EmailAddress : EmailAddress.EmailAddress -> Evergreen.V80.EmailAddress2.EmailAddress
migrate_EmailAddress2_EmailAddress old =
    let
        fromString : String -> Maybe Evergreen.V80.EmailAddress2.EmailAddress
        fromString string =
            case Parser.run parseEmail string of
                Ok result ->
                    result

                _ ->
                    Nothing

        parseEmail : Parser (Maybe Evergreen.V80.EmailAddress2.EmailAddress)
        parseEmail =
            let
                split char parser =
                    Parser.loop []
                        (\r ->
                            Parser.oneOf
                                [ Parser.succeed (\tld -> Parser.Loop (tld :: r))
                                    |. Parser.symbol (String.fromChar char)
                                    |= parser
                                , Parser.succeed ()
                                    |> Parser.map (\_ -> Parser.Done (List.reverse r))
                                ]
                        )
            in
            Parser.succeed
                (\localPart tags domain tlds ->
                    let
                        fullLocalPart =
                            String.join ""
                                [ localPart
                                , case tags of
                                    [] ->
                                        ""

                                    _ ->
                                        "+" ++ String.join "+" tags
                                ]
                    in
                    if String.length fullLocalPart > 64 then
                        Nothing

                    else if List.length tlds < 1 then
                        Nothing

                    else
                        { localPart = String.toLower localPart
                        , tags = List.map String.toLower tags
                        , domain = String.toLower domain
                        , tld = List.map String.toLower tlds
                        }
                            |> Evergreen.V80.EmailAddress2.EmailAddress
                            |> Just
                )
                |= parseLocalPart
                |= split '+' parseLocalPart
                |. Parser.symbol "@"
                |= parseDomain
                |= split '.' parseTld
                |. Parser.end

        parseLocalPart : Parser String
        parseLocalPart =
            Parser.succeed ()
                |. Parser.chompWhile
                    (\a ->
                        (a /= '+')
                            && (a /= '@')
                            && (a /= '\\')
                            && (a /= '"')
                    )
                |> Parser.getChompedString
                |> Parser.andThen
                    (\localPart ->
                        if String.startsWith "." localPart || String.endsWith "." localPart || String.indexes ".." localPart /= [] then
                            Parser.problem "localPart can't start or end with a dot, nor can there be double dots"

                        else if String.trim localPart /= localPart then
                            Parser.problem "localPart can't be wrapped with whitespace"

                        else
                            Parser.succeed localPart
                    )

        parseDomain : Parser String
        parseDomain =
            Parser.succeed ()
                |. Parser.chompWhile
                    (\a ->
                        (Char.isAlphaNum a
                            || (a == '-')
                        )
                            && (a /= '@')
                            && (a /= '.')
                    )
                |> Parser.getChompedString
                |> Parser.andThen
                    (\a ->
                        if String.length a < 1 then
                            Parser.problem "Domain has to be atleast 1 character long."

                        else
                            Parser.succeed a
                    )

        parseTld : Parser String
        parseTld =
            Parser.succeed ()
                |. Parser.chompWhile
                    (\a ->
                        Char.isUpper a
                            || Char.isLower a
                            || (a == '-')
                    )
                |> Parser.getChompedString
                |> Parser.andThen
                    (\a ->
                        if String.length a >= 2 then
                            Parser.succeed a

                        else
                            Parser.problem "Tld needs to be at least 2 character long."
                    )
    in
    case EmailAddress.toString old |> fromString of
        Just email ->
            email

        Nothing ->
            unreachable 0


{-| Be very careful when using this!
-}
unreachable : Int -> a
unreachable v =
    unreachable (causeStackOverflow v)


causeStackOverflow : Int -> Int
causeStackOverflow value =
    causeStackOverflow value + 1


migrate_GridCell_Cell : Evergreen.V79.GridCell.Cell -> Evergreen.V80.GridCell.Cell
migrate_GridCell_Cell old =
    case old of
        Evergreen.V79.GridCell.Cell p0 ->
            Evergreen.V80.GridCell.Cell
                { history =
                    p0.history
                        |> List.map
                            (\rec1 ->
                                { userId = rec1.userId |> migrate_User_UserId
                                , position = rec1.position
                                , line = rec1.line |> migrate_List_Nonempty_Nonempty migrate_Ascii_Ascii
                                }
                            )
                , undoPoint = p0.undoPoint
                }


migrate_Grid_Grid : Evergreen.V79.Grid.Grid -> Evergreen.V80.Grid.Grid
migrate_Grid_Grid old =
    case old of
        Evergreen.V79.Grid.Grid p0 ->
            Evergreen.V80.Grid.Grid (p0 |> Dict.map (\k -> migrate_GridCell_Cell))


migrate_Helper_Coord : (units_old -> units_new) -> Evergreen.V79.Helper.Coord units_old -> Evergreen.V80.Helper.Coord units_new
migrate_Helper_Coord migrate_units old =
    old |> Tuple.mapBoth migrate_Quantity_Quantity migrate_Quantity_Quantity


migrate_List_Nonempty_Nonempty : (a_old -> a_new) -> List.Nonempty.Nonempty a_old -> List.Nonempty.Nonempty a_new
migrate_List_Nonempty_Nonempty migrate_a old =
    old |> List.Nonempty.map migrate_a


migrate_NotifyMe_Frequency : Evergreen.V79.NotifyMe.Frequency -> Evergreen.V80.NotifyMe.Frequency
migrate_NotifyMe_Frequency old =
    case old of
        Evergreen.V79.NotifyMe.Every3Hours ->
            Evergreen.V80.NotifyMe.Every3Hours

        Evergreen.V79.NotifyMe.Every12Hours ->
            Evergreen.V80.NotifyMe.Every12Hours

        Evergreen.V79.NotifyMe.Daily ->
            Evergreen.V80.NotifyMe.Daily

        Evergreen.V79.NotifyMe.Weekly ->
            Evergreen.V80.NotifyMe.Weekly

        Evergreen.V79.NotifyMe.Monthly ->
            Evergreen.V80.NotifyMe.Monthly


migrate_Quantity_Quantity : Quantity.Quantity number units -> Quantity.Quantity number units2
migrate_Quantity_Quantity old =
    Quantity.unwrap old |> Quantity.unsafe


migrate_RecentChanges_RecentChanges : Evergreen.V79.RecentChanges.RecentChanges -> Evergreen.V80.RecentChanges.RecentChanges
migrate_RecentChanges_RecentChanges old =
    case old of
        Evergreen.V79.RecentChanges.RecentChanges p0 ->
            Evergreen.V80.RecentChanges.RecentChanges
                { frequencies =
                    p0.frequencies
                        |> AssocList.toList
                        |> List.map
                            (Tuple.mapBoth
                                migrate_NotifyMe_Frequency
                                (\dict ->
                                    Dict.map (\k value -> migrate_GridCell_Cell value) dict
                                )
                            )
                        |> SeqDict.fromList
                , threeHoursElapsed = p0.threeHoursElapsed |> migrate_Quantity_Quantity
                }


migrate_Types_BackendUserData : Evergreen.V79.Types.BackendUserData -> Evergreen.V80.Types.BackendUserData
migrate_Types_BackendUserData old =
    { hiddenUsers = old.hiddenUsers |> SeqSet.map migrate_User_UserId
    , hiddenForAll = old.hiddenForAll
    , undoHistory = old.undoHistory
    , redoHistory = old.redoHistory
    , undoCurrent = old.undoCurrent
    }


migrate_Types_PendingEmail : Evergreen.V79.Types.PendingEmail -> Evergreen.V80.Types.PendingEmail
migrate_Types_PendingEmail old =
    { email = old.email |> migrate_EmailAddress2_EmailAddress
    , frequency = old.frequency |> migrate_NotifyMe_Frequency
    , creationTime = old.creationTime
    , userId = old.userId |> migrate_User_UserId
    , key = old.key |> migrate_UrlHelper_ConfirmEmailKey
    }


migrate_Types_SubscribedEmail : Evergreen.V79.Types.SubscribedEmail -> Evergreen.V80.Types.SubscribedEmail
migrate_Types_SubscribedEmail old =
    { email = old.email |> migrate_EmailAddress2_EmailAddress
    , frequency = old.frequency |> migrate_NotifyMe_Frequency
    , confirmTime = old.confirmTime
    , userId = old.userId |> migrate_User_UserId
    , unsubscribeKey = old.unsubscribeKey |> migrate_UrlHelper_UnsubscribeEmailKey
    }


migrate_Units_AsciiUnit : Evergreen.V79.Units.AsciiUnit -> Evergreen.V80.Units.AsciiUnit
migrate_Units_AsciiUnit old =
    case old of
        Evergreen.V79.Units.AsciiUnit p0 ->
            Evergreen.V80.Units.AsciiUnit p0


migrate_Units_CellUnit : Evergreen.V79.Units.CellUnit -> Evergreen.V80.Units.CellUnit
migrate_Units_CellUnit old =
    case old of
        Evergreen.V79.Units.CellUnit p0 ->
            Evergreen.V80.Units.CellUnit p0


migrate_UrlHelper_ConfirmEmailKey : Evergreen.V79.UrlHelper.ConfirmEmailKey -> Evergreen.V80.UrlHelper.ConfirmEmailKey
migrate_UrlHelper_ConfirmEmailKey old =
    case old of
        Evergreen.V79.UrlHelper.ConfirmEmailKey p0 ->
            Evergreen.V80.UrlHelper.ConfirmEmailKey p0


migrate_UrlHelper_UnsubscribeEmailKey : Evergreen.V79.UrlHelper.UnsubscribeEmailKey -> Evergreen.V80.UrlHelper.UnsubscribeEmailKey
migrate_UrlHelper_UnsubscribeEmailKey old =
    case old of
        Evergreen.V79.UrlHelper.UnsubscribeEmailKey p0 ->
            Evergreen.V80.UrlHelper.UnsubscribeEmailKey p0


migrate_User_UserId : Evergreen.V79.User.UserId -> Evergreen.V80.User.UserId
migrate_User_UserId old =
    case old of
        Evergreen.V79.User.UserId p0 ->
            Evergreen.V80.User.UserId p0
